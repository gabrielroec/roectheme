{% comment %}
Auto-generated by Shogun-AB.
This file can be re-written at any time.
{% endcomment %}

<script id="shgab-template-handler-script" type="text/javascript" class="shgab">
  ;(function() {
    const urlParams = new URLSearchParams(window.location.search);
    const cacheEnabled = urlParams.get('cache') == "false" ? false : true
    const optimizationDisabled = urlParams.get('shg') == "false"
    const config = {{shop.metafields.shgabc.optimizations | default: 'null'}} || {}
    const optimizations = config.expires_at > Date.now() ? (config.optimizations || []) : []
    const currentThemeId = "173429751992"
    const defaultThemeId = config.default_theme_id
    const pageId = "{{ content.id }}"
    const pageType = "{% if article %}article{% elsif blog %}blog{% elsif page %}page{% elsif product %}product{% elsif collection %}collection{% elsif metaobject %}metaobject{% else %}homepage{% endif %}"
    const templateName = "{{ template.name }}"
    const templateSuffix = "{{ template.suffix }}"

    // we do not have the file extension of the current template, so the best we can do is templates/templateName.templateSuffix, e.g., templates/product.wide
    // but it's also super important to include metaobject/ because you can have conflicts between templates/product.json and templates/metaobject/product.json (and others)
    const templatePrefix = pageType == "metaobject" ? "templates/metaobject/" : "templates/"
    const currentPartialTemplateKey = templatePrefix + (templateSuffix ? `${templateName}.${templateSuffix}` : templateName)

    const customerId = "{{ customer.id }}"
    const visitorDetailsKey = '_shg_ab_visitor_details'
    const optimizationsCacheKey = '_shg_ab_optimizations_cache'
    const currentTime = new Date().getTime()
    const numberOfBins = 10000
    const distributionMethod = urlParams.get('shgMethod') || config.method;
    const sessionId = urlParams.get('shgSessionId') || getCookie('_shopify_s')
    const designMode = {{ request.design_mode }}

    var variantRendered = false
    var cachedOptimizations = JSON.parse(localStorage.getItem(optimizationsCacheKey)) || {}
    var personalizationVariant;

    function getCookie(cname) {
      let name = cname + "=";
      let decodedCookie = decodeURIComponent(document.cookie);
      let ca = decodedCookie.split(';');
      for(let i = 0; i <ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) == ' ') {
          c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
          return c.substring(name.length, c.length);
        }
      }
      return "";
    }

    function userBin() {
      let userId = sessionId
      let hash = 0;

      for (let i = 0; i < userId.length; i++) {
        hash = ((hash << 5) - hash) + userId.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return Math.abs(hash) % numberOfBins;
    }

    function getRandomVariantForOptimization(optimization) {
      var rand = Math.random()
      var threshold = 0

      for (const variant of optimization.variants) {
        threshold += variant.config.percentage / 100
        if(threshold > rand) return variant
      }
    }

    function getVariantForUserBin() {
      const bin = userBin()
      console.debug(`User ${sessionId} is in bin ${bin} of ${numberOfBins}`)
      const ab_tests = optimizations.filter(o => o.type === "ab_test")
      const variants = ab_tests.flatMap(o => o.variants)

      let threshold = 0;

      for (const variant of variants) {
        threshold += numberOfBins * variant.traffic_percentage / 100;
        if (bin < threshold) {
          return variant;
        }
      }

      return null;
    }

    // Returns template file without file extension
    // ie - templates/product.something.json -> templates/product.something
    // ie - templates/product.json -> templates/product
    // ie - templates/metaobject/product.json -> templates/metaobject/product
    function extractPartialTemplateKeyFromFullTemplateKey(fullTemplateKey) {
      if(!fullTemplateKey) return

      // Split by dots and remove the last part (file extension)
      const parts = fullTemplateKey.split('.')
      return parts.slice(0, -1).join('.')
    }

    function getPartialTemplateKeyFromDefaultVariant(optimization) {
      if (!optimization || !optimization.variants) return
      const originalVariant = optimization.variants.find(variant => variant.config.original === true)
      return extractPartialTemplateKeyFromFullTemplateKey(originalVariant?.config.full_template_key)
    }

    var geoData = {};
const geoDataKey = 'shg_geo_data';
try {
  const cachedGeoData = fetchGeoDataFromCache();
  if (cachedGeoData) {
    geoData = cachedGeoData;
  } else {
    geoData = fetchGeoDataFromApi();
  }
} catch (error) {
  geoData = {};
}

function fetchGeoDataFromCache() {
  if (urlParams.get('shg_geo_cache') === 'false') {
    return;
  }
  var cachedGeoData;

  try {
    const storedGeoData = localStorage.getItem(geoDataKey);
    if (storedGeoData) {
      const parsedGeoData = JSON.parse(storedGeoData);
      const now = new Date().getTime();
      if (daysInBetween(now, parsedGeoData.timestamp) > 7) {
        return;
      }
      cachedGeoData = parsedGeoData;
    }
  } catch (error) {
    return;
  }
  return cachedGeoData;
}

function daysInBetween(timestamp1, timestamp2) {
  var difference = timestamp1 - timestamp2;
  var daysDifference = Math.floor(difference / 1000 / 60 / 60 / 24); // division by 1000 to seconds, by 60 to min, by 60 to hour, by 24 to days

  return daysDifference;
}

function fetchGeoDataFromApi() {
  var geoData = {};
  const geoApiRequest = new XMLHttpRequest();
  geoApiRequest.open("GET", "https://ipinfo.io/json?token=f2ae3a557d807b", false);
  geoApiRequest.send(null);
  if (geoApiRequest.status === 200) {
    geoData = JSON.parse(geoApiRequest.responseText);
    geoData.timestamp = new Date().getTime();
    localStorage.setItem(geoDataKey, JSON.stringify(geoData));
  }
  return geoData;
}


    var deviceChecker = function(value) {
  device = window.innerWidth < 768 ? "mobile" : "desktop"
  return value === device
}


    var loggedInChecker = function() {
  return Boolean(customerId)
}


    var visitorDetails = JSON.parse(localStorage.getItem(visitorDetailsKey) || null)

// expectedData: object
//    expectedTimeInMillseconds: integer - 120000
//    withinOrAfter: string - 'within' or 'after'
var returningVisitorChecker = function(expectedData) {
  const { expectedTimeInMillseconds, withinOrAfter } = expectedData || {}

  if (withinOrAfter === 'within') {
    return (visitorDetails.first_visit_timestamp + expectedTimeInMillseconds) > currentTime
  } else {
    return (visitorDetails.first_visit_timestamp + expectedTimeInMillseconds) < currentTime
  }
}

// expectedData: String 'true' or 'false'
var newVisitorChecker = function(expectedData) {
  // They are not a new visitor if there is more than 30 minutes since their first visit
  let isNew = (currentTime - visitorDetails.first_visit_timestamp) < 1800000
  return isNew.toString() === expectedData
}

var setVisitorDetails = function() {
  // This is the first time so we set it to the current time
  if (visitorDetails === null) {
    visitorDetails = {
      first_visit_timestamp: currentTime
    }
  }

  localStorage.setItem(visitorDetailsKey, JSON.stringify(visitorDetails))
}

setVisitorDetails()


    var urlContainsChecker = function(expectedString) {
  let url = window.location.href
  return url.toLowerCase().includes(expectedString.toLowerCase())
}


    var referrerContainsChecker = function(expectedString) {
  return document.referrer.toLowerCase().includes(expectedString.toLowerCase())
}


    const locationChecker = function(expectedGeoData) {
  const { type, countryCode, toponymName, parentName } = expectedGeoData || {};
  const { country, region, city } = geoData || {};

  switch (type) {
    case "country":
      return country === countryCode;
    case "region":
      return region === toponymName && country === countryCode;
    case "city":
      return city === toponymName && region === parentName && country === countryCode;
    default:
      console.debug("Unknown location type:", type);
      return false;
  }
}


    var audienceCheckers = {
      "device": deviceChecker,
      "logged_in": loggedInChecker,
      "new_visitor": newVisitorChecker,
      "returning_visitor": returningVisitorChecker,
      "url_contains": urlContainsChecker,
      "referrer_contains": referrerContainsChecker,
      "location": locationChecker
    }

    var inAudience = function(audience) {
      const matched = Boolean(audienceCheckers[audience.audience_type]?.(audience.value))
      console.debug("Audience matched", audience, matched)
      return audience.condition === 'is_not' ? !matched : matched
    }

    function matchTestToPersonalization(optimization) {
      const persTemplate = extractPartialTemplateKeyFromFullTemplateKey(personalizationVariant.config.full_template_key)

      if(optimization.scope == "page" || optimization.scope == "template") {
        const defaultTemplate = getPartialTemplateKeyFromDefaultVariant(optimization)
        if(persTemplate == defaultTemplate) {
          console.debug("Personalization to Test match found, matching target found", persTemplate, defaultTemplate)
          return true
        }
      }

      console.debug("No Personalization to Test match found")
      return false
    }

    function matchesTarget(optimization) {
      if(!optimization) {
        console.debug("No optimization found")
        return false
      }

      if(personalizationVariant) {
        return matchTestToPersonalization(optimization)
      }

      if(optimization.scope == "page" && optimization.config.page_type == pageType) {
        if (pageId == "") {
          console.debug("Homepage type is targeted by this page optimization", pageType, optimization.config.page_type)
          return true
        }
        if(pageId != "" && pageId == optimization.config.page_id) {
          console.debug("Current page is targeted by the page optimization", pageId, optimization.config.page_id, pageType, optimization.config.page_type)
          return true
        }
      }

      const targetTemplate = getPartialTemplateKeyFromDefaultVariant(optimization)
      if(optimization.scope == "template") {
        if(currentPartialTemplateKey == targetTemplate) {
          console.debug("Current template is targeted by the template optimization", currentPartialTemplateKey, targetTemplate)
          return true
        }
      }

      if(optimization.scope == 'theme' && currentThemeId == optimization.config.theme_id) {
        console.debug("Current theme is targeted by the theme optimization", currentThemeId, optimization.config.theme_id)
        return true
      }

      console.debug("No optimization with matching target found")
      return false
    }

    function matchTestToPersonalizationAudience(optimizationAudiences) {
      const persAudiences = personalizationVariant.config.audiences

      if (persAudiences.length !== optimizationAudiences.length) {
        console.debug("Audience arrays are of different lengths, not a match");
        return false
      }

      // Regardless of audiences order, they need to match
      const areAudiencesMatching = persAudiences.every(persAudience =>
        optimizationAudiences.some(optAudience => JSON.stringify(persAudience) === JSON.stringify(optAudience))
      )

      console.debug("matchTestToPersonalizationAudience match:", areAudiencesMatching)

      return areAudiencesMatching
    }

    function matchesAudience(config) {
      if(!config) {
        console.debug("No config found, something is wrong here")
        return false
      }

      if(personalizationVariant) {
        return matchTestToPersonalizationAudience(config.audiences)
      }

      // If no audiences defined, always match
      if (!config.audiences) {
        console.debug("No audience defined, matching by default")
        return true
      }

      console.debug("Checking audience match")
      return config.audiences_condition === 'every'
        ? config.audiences.every(inAudience)
        : config.audiences.some(inAudience)
    }

    function removePreviewBarIframe() {
      console.debug("Setting up preview bar iframe removal");

      // Function to remove the iframe if it exists
      function removeIfExists() {
        const iframe = document.getElementById('preview-bar-iframe');
        if (iframe) {
          console.debug("Removing preview bar iframe");
          iframe.remove();
        }
      }

      // Try to remove immediately in case it's already there
      removeIfExists();

      // Set up the observer once the DOM is fully loaded
      document.addEventListener('DOMContentLoaded', function() {
        console.debug("DOM loaded, setting up mutation observer");

        // Create a mutation observer to watch for the preview bar iframe
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.addedNodes) {
              mutation.addedNodes.forEach(function(node) {
                // Check if the added node is the preview bar iframe or contains it
                if (node.id === 'preview-bar-iframe') {
                  console.debug("Detected and removing preview bar iframe");
                  node.remove();
                }
              });
            }
          });
        });

        // Start observing the document body for changes
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });

        // Do one more check after DOM is loaded
        removeIfExists();
      });
    }

    function checkStoreTheme(themeId) {
      // If no themeId is provided, use the default
      if(!themeId) {
        console.debug("No themeId provided, using default theme")
        themeId = defaultThemeId
      }

      // If we're already on the correct theme, no need to redirect
      if (currentThemeId == themeId) {
        console.debug("Already on the correct theme, no redirect needed")
        removePreviewBarIframe()
        return
      }

      // not on the correct theme, redirect to the variant theme
      console.debug("On incorrect theme, redirecting to variant theme")
      const url = new URL(window.location.href)

      // Set the preview_theme_id parameter to the variant's theme_id
      url.searchParams.set("preview_theme_id", themeId)

      // Redirect to the new URL
      console.debug("Redirecting to:", url.toString())
      window.location.href = url.toString()
      throw new Error("Redirecting to variant theme")
    }

    function getVariant() {
      const personalizations = optimizations.filter(optimization => optimization?.type === "personalization")
      const abTests = optimizations.filter(optimization => optimization?.type === "ab_test")

      // Check personalizations first
      for (let optimization of personalizations) {
        if (matchesTarget(optimization)) {
          for (let variant of optimization.variants) {
            if(!variant.config.original && matchesAudience(variant.config)) {
              personalizationVariant = variant
              console.debug(`Visitor is in personalization variant ${variant.name} of ${optimization.name}`);
              break
            }
          }
        }
      }

      // If method is even distribution, assign user to a variant based on the session id, and store it in cache.
      if (distributionMethod === "even") {
        const variant = getVariantForUserBin()

        if (!variant) {
          console.debug("No variant found for user bin, something is wrong here!")
          return
        }

        const optimization = abTests.find(optimization => optimization.id === variant.optimization_id)

        if (matchesTarget(optimization) && matchesAudience(optimization.config)) {
          console.debug(`Visitor is in evenly assigned variant ${variant.name} of ${optimization.name}`)
          localStorage.setItem(optimizationsCacheKey, JSON.stringify({ ...cachedOptimizations, [optimization.id]: variant.id}))
          return variant
        }

      // Fallback to greedy distribution
      } else {
        for (let optimization of abTests) {
          if (matchesTarget(optimization) && matchesAudience(optimization.config)) {
            let variant;
            if (cacheEnabled && cachedOptimizations[optimization.id]) {
              variant = optimization.variants.find(variant => variant.id === cachedOptimizations[optimization.id])
              console.debug(`Found cached variant ${variant.name} of ${optimization.name}`)
            } else {
              variant = getRandomVariantForOptimization(optimization);
            }

            console.debug(`Visitor is in greedly assigned variant ${variant.name} of ${optimization.name}`)
            localStorage.setItem(optimizationsCacheKey, JSON.stringify({ ...cachedOptimizations, [optimization.id]: variant.id}))
            return variant;
          }
        }
      }
    }

    function renderHeadTemplateContent() {
      if (variantRendered) return
      const template = document.getElementById("shogun-ab-variant-head");
      if (template) {
        document.write(template.innerHTML);
      }
      variantRendered = true
    }

    function extractViewParamFromFullTemplateKey(fullTemplateKey) {
      const parts = fullTemplateKey.split('/').pop().split('.')
      return parts.slice(1, parts.length - 1).join('.')
    }

    function loadVariant(variant, xhr) {
      const url = new URL(window.location.href)

      const viewParam = extractViewParamFromFullTemplateKey(variant.config.full_template_key)

      if(viewParam == templateSuffix) {
        console.debug("Variant template is the same as the current template, no need to loadVariant")
        return
      }

      console.debug("viewParam", viewParam)
      url.searchParams.set("view", viewParam)
      const variantUrl = url.pathname + url.search + url.hash

      xhr.open("GET", variantUrl, false /* make request run synchronously */)
      xhr.withCredentials = true
      xhr.send()

      if (xhr.status !== 200) {
        return
      } else {
        const parser = new DOMParser()
        const variantDocument = parser.parseFromString(xhr.responseText, "text/html")

        const head = variantDocument.getElementById("shogun-ab-variant-head")
        const body = variantDocument.getElementById("shogun-ab-variant-body")

        document
          .getElementById("shogun-ab-variant-head")
          .replaceWith(head);

        // we should set this after all other head related ops have completed in case they fail
        // as in that case the default body should be used
        window.SHOGUN_ABC_CACHED_VARIANT_BODY = body
      }
    }

    function trackVariantImpression(variant) {
      if (!variant) {
        console.debug("No variant to track")
        shogunLoaded({ page_type: pageType, page_id: pageId });
        return;
      }

      console.debug("Tracking variant impression", variant.id);
      shogunLoaded({
        optimization_id: variant.optimization_id,
        variant_id: variant.id,
        page_type: pageType,
        page_id: pageId
      });
    }

    function processVariant(variant) {
      let variantToLoad = variant
      checkStoreTheme(variant?.config?.theme_id)

      if(personalizationVariant) {
        console.debug("Personalization variant found", personalizationVariant)
        if(!variant) {
          console.debug("But no test variant found")
          variantToLoad = personalizationVariant
        } else if (variant.config.original) {
          console.debug("And original test variant found")
          trackVariantImpression(personalizationVariant)
          // Allow the test variant to be loaded
        }
      }

      if (!variantToLoad) {
        console.debug("No variant found")
        trackVariantImpression(null)
        return;
      }

      console.debug("Loading variant:", variantToLoad)
      const xhr = new XMLHttpRequest()
      loadVariant(variantToLoad, xhr)
      trackVariantImpression(variantToLoad)
    }

    function startOptimization() {
      if (variantRendered) {
        console.debug("Variant already rendered")
        return
      }

      if(designMode) {
        console.debug("Design mode enabled, skipping variant selection")
        return;
      }

      const variant = getVariant()
      processVariant(variant);
    }

    function shogunLoaded(options) {
      document.addEventListener('DOMContentLoaded', function() {
        console.debug("shogunLoaded", options);
        Shopify.analytics.publish('shogun:load', options);
      });
    }

    if (optimizationDisabled) {
      console.debug("Shogun optimization disabled - skipping")
      return processVariant(null)
    }

    startOptimization()
    // Make sure that the head template content is rendered even if there is no variant to serve
    renderHeadTemplateContent()
  })()
</script>
